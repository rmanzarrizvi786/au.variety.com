<?php

namespace Oriel;

use Exception;


define( 'INTERVAL_START', ord( '-' ) );
define( 'INTERVAL_END', ord( 'z' ) );
define( 'INTERVAL_LENGTH', INTERVAL_END - INTERVAL_START + 1 );

require_once ORIEL__DIR . '/includes/mbstring.php';


/**
 * The Crypto class provides resources to perform various cryptographic tasks,
 * such as token verification
 */
class Crypto {


	/**
	 * Replaces substitute source attributes with real ones in page.
	 *
	 * @param  string $script - Parent script tag
	 * @return string - Script tag including new logic
	 */

	public static function inject_settings_in_loader( $str, $loader ) {
		return str_replace( '"ujxphdr"', $str, $loader );
	}

	public static function settings_placeholder_exists( $loader ) {
		return preg_match( '"ujxphdr"', $loader );
	}

	/**
	 * Generates a random string of the given {@code length}.
	 *
	 * @param  integer $length The length of the key.
	 * @return string The generated key.
	 * @throws Exception If the length of the key is not grater than 0.
	 */
	public static function generateRandomKey( $length ) {
		return self::generateRandomKeyBySeed( rand( -2147483648, 1073741823 ), $length );
	}

	/**
	 * Generates a random string of the given {@code length}.
	 *
	 * This is an overload that also takes a {@code seed} for deterministic
	 * results. The key is not cryptographically strong, the numbers
	 * generated by the algorithm being "pseudo-random". Which is fine
	 * for our use case and for performance reasons.
	 *
	 * NOTE: the algorithm used is the linear congruential generator, see
	 * <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">article</a>.
	 *
	 * @param  integer $seed   The seed.
	 * @param  integer $length The length of the key.
	 * @return string The random generated key.
	 * @throws Exception If the {@code length} is not grater than 0.
	 */
	public static function generateRandomKeyBySeed( $seed, $length ) {
		if ( $length < 1 ) {
			throw new Exception( 'Length should be strictly positive' );
		}

		$builder = '';
		$state   = $seed;

		for ( $i = 0; $i < $length; $i++ ) {
			$state    = ( $state * 0x5DEECE66D + 0xB ) & 0xFFFFFFFFFFFF;
			$n        = intval( $state >> 16 );
			$builder .= mb_chr( ( INTERVAL_START + self::floorMod( $n, INTERVAL_LENGTH ) ) );
		}
		return $builder;
	}

	/**
	 * Obfuscates text that can be de-obfuscated via {@link #deobfuscateTextByModulo}.
	 *
	 * The algorithm is symmetric (i.e. the same key can be used for
	 * de-obfuscating it) and does not have good cryptographic strength, but
	 * works for our purposes.
	 *
	 * @param  string $key     is the key used to obfuscate the text
	 * @param  string $content is the text to be obfuscated
	 * @return string The obfuscated {@code $content}.
	 */
	public static function obfuscateTextByModulo( $key, $content ) {
		return self::transformTextByModulo(
			$key, $content, function ( $sch, $kch ) {
				return $sch + $kch;
			}
		);
	}

	/**
	 * De-obfuscates text processed returned by {@link #obfuscateTextByModulo}.
	 *
	 * @param  string $key     The key used to obfuscate the text.
	 * @param  string $content The text to be de-obfuscated.
	 * @return string The {@code $content} de-obfuscated.
	 */
	public static function deobfuscateTextByModulo( $key, $content ) {
		return self::transformTextByModulo(
			$key, $content, function ( $sch, $kch ) {
				return $sch - $kch;
			}
		);
	}

	/**
	 * Transforms the {@code $content}.
	 *
	 * @param  string   $key     The key used for transforming the {@code $content}.
	 * @param  string   $content The content to be transformed.
	 * @param  callable $fn      Depending on this function the text can be obfuscated or de-obfuscated
	 *                           since the algorithm is symmetric.
	 * @return string The resulted text.
	 */
	private static function transformTextByModulo( $key, $content, callable $fn ) {
		$builder = '';
		$keyIdx  = 0;

		// Use `mb_strlen` instead of `strlen` since `strlen` returns the number of bytes.
		for ( $i = 0; $i < mb_strlen( $content ); $i++ ) {
			$sch0   = mb_ord( mb_substr( $content, $i, 1 ) );
			$kch0   = mb_ord( mb_substr( $key, $keyIdx, 1 ) );
			$keyIdx = ( $keyIdx + 1 ) % mb_strlen( $key );

			// Not readable?
			if ( $sch0 < INTERVAL_START || $sch0 > INTERVAL_END ) {
				$builder .= mb_chr( $sch0 );
				continue;
			}

			$sch      = $sch0 - INTERVAL_START;
			$kch      = $kch0 - INTERVAL_START;
			$shifted  = self::floorMod( $fn( $sch, $kch ), INTERVAL_LENGTH ) + INTERVAL_START;
			$builder .= mb_chr( $shifted );
		}

		return $builder;
	}

	private static function floorMod( $n, $m ) {
		return ( ( $n % $m ) + $m ) % $m;
	}
}


